import{_ as a,c as r,o as t,ag as s}from"./chunks/framework.kA1e5MDl.js";const p=JSON.parse('{"title":"Type Alias: Scheduler","description":"","frontmatter":{},"headers":[],"relativePath":"api/type-aliases/Scheduler.md","filePath":"api/type-aliases/Scheduler.md","lastUpdated":null}'),o={name:"api/type-aliases/Scheduler.md"};function i(l,e,c,n,d,u){return t(),r("div",null,[...e[0]||(e[0]=[s('<h1 id="type-alias-scheduler" tabindex="-1">Type Alias: Scheduler <a class="header-anchor" href="#type-alias-scheduler" aria-label="Permalink to &quot;Type Alias: Scheduler&quot;">​</a></h1><blockquote><p><strong>Scheduler</strong> = <code>object</code></p></blockquote><p>Defined in: <a href="https://github.com/actioncrew/streamix/blob/main/projects/libraries/streamix/src/lib/abstractions/scheduler.ts#L19" target="_blank" rel="noreferrer">abstractions/scheduler.ts:19</a></p><p>Functional Scheduler</p><p>Guarantees:</p><ul><li>FIFO execution (one task at a time)</li><li>Supports synchronous and asynchronous tasks</li><li>Errors reject the task promise but do NOT stop the queue</li><li><code>flush()</code> is microtask-stable: it resolves only after the queue stays empty across a microtask turn (prevents “flush lies”)</li></ul><p>Performance optimizations:</p><ul><li>Parallel arrays instead of per-task objects</li><li>At most one pump in flight</li><li>Compact storage for flush waiters</li></ul><h2 id="properties" tabindex="-1">Properties <a class="header-anchor" href="#properties" aria-label="Permalink to &quot;Properties&quot;">​</a></h2><h3 id="enqueue" tabindex="-1">enqueue() <a class="header-anchor" href="#enqueue" aria-label="Permalink to &quot;enqueue()&quot;">​</a></h3><blockquote><p><strong>enqueue</strong>: &lt;<code>T</code>&gt;(<code>fn</code>) =&gt; <code>Promise</code>&lt;<code>T</code>&gt;</p></blockquote><p>Defined in: <a href="https://github.com/actioncrew/streamix/blob/main/projects/libraries/streamix/src/lib/abstractions/scheduler.ts#L26" target="_blank" rel="noreferrer">abstractions/scheduler.ts:26</a></p><p>Enqueue a task for serialized execution.</p><p>The task may return a value or a promise. The returned promise resolves or rejects with the task result.</p><h4 id="type-parameters" tabindex="-1">Type Parameters <a class="header-anchor" href="#type-parameters" aria-label="Permalink to &quot;Type Parameters&quot;">​</a></h4><h5 id="t" tabindex="-1">T <a class="header-anchor" href="#t" aria-label="Permalink to &quot;T&quot;">​</a></h5><p><code>T</code></p><h4 id="parameters" tabindex="-1">Parameters <a class="header-anchor" href="#parameters" aria-label="Permalink to &quot;Parameters&quot;">​</a></h4><h5 id="fn" tabindex="-1">fn <a class="header-anchor" href="#fn" aria-label="Permalink to &quot;fn&quot;">​</a></h5><p>() =&gt; <code>Promise</code>&lt;<code>T</code>&gt; | <code>T</code></p><h4 id="returns" tabindex="-1">Returns <a class="header-anchor" href="#returns" aria-label="Permalink to &quot;Returns&quot;">​</a></h4><p><code>Promise</code>&lt;<code>T</code>&gt;</p><hr><h3 id="flush" tabindex="-1">flush() <a class="header-anchor" href="#flush" aria-label="Permalink to &quot;flush()&quot;">​</a></h3><blockquote><p><strong>flush</strong>: () =&gt; <code>Promise</code>&lt;<code>void</code>&gt;</p></blockquote><p>Defined in: <a href="https://github.com/actioncrew/streamix/blob/main/projects/libraries/streamix/src/lib/abstractions/scheduler.ts#L32" target="_blank" rel="noreferrer">abstractions/scheduler.ts:32</a></p><p>Resolves when the scheduler becomes idle and remains idle across a microtask boundary.</p><h4 id="returns-1" tabindex="-1">Returns <a class="header-anchor" href="#returns-1" aria-label="Permalink to &quot;Returns&quot;">​</a></h4><p><code>Promise</code>&lt;<code>void</code>&gt;</p>',29)])])}const m=a(o,[["render",i]]);export{p as __pageData,m as default};
